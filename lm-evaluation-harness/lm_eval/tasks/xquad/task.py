"""
Know What You Don’t Know: Unanswerable Questions for SQuAD
https://arxiv.org/pdf/1806.03822.pdf

Stanford Question Answering Dataset (SQuAD) is a reading comprehension dataset,
consisting of questions posed by crowdworkers on a set of Wikipedia articles,
where the answer to every question is a segment of text, or span, from the
corresponding reading passage, or the question might be unanswerable.
SQuAD2.0 combines the 100,000 questions in SQuAD1.1 with over 50,000 unanswerable
questions written adversarially by crowdworkers to look similar to answerable ones.
To do well on SQuAD2.0, systems must not only answer questions when possible, but
also determine when no answer is supported by the paragraph and abstain from answering.

Homepage: https://rajpurkar.github.io/SQuAD-explorer/
"""

from functools import partial
from math import exp

import datasets
import evaluate
from packaging import version

from lm_eval.api.instance import Instance
from lm_eval.api.task import ConfigurableTask


_CITATION = """
@misc{rajpurkar2018know,
    title={Know What You Don't Know: Unanswerable Questions for SQuAD},
    author={Pranav Rajpurkar and Robin Jia and Percy Liang},
    year={2018},
    eprint={1806.03822},
    archivePrefix={arXiv},
    primaryClass={cs.CL}
}
"""


def _squad_metric(predictions, references):
    squad_metric = evaluate.load("/home/export/base/ycsc_chenkh/hitici_02/online1/LLaMA-Factory/lm-evaluation-harness/metrics/squad_v2", trust_remote_code=True)
    return squad_metric.compute(predictions=predictions, references=references)


def _squad_agg(key, items):
    predictions, references = zip(*items)

    return _squad_metric(predictions=predictions, references=references).get(key, 0)

def doc_to_text(doc, connector):
    return (
        f"{connector['Background']}: "
        + doc["context"]
        + "\n\n"
        + f"{connector['Question']}: "
        + doc["question"]
        + "\n\n"
        + f"{connector['Answer']}:"
    )

class XQuAD(ConfigurableTask):
    VERSION = 1
    DATASET_PATH = "/online1/ycsc_chenkh/hitici_02/data/eval_data/xquad"
    DATASET_NAME = "xquad.en"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    # HF changed squad on us so we have to make sure we aren't running the old one
    assert version.parse(datasets.__version__) >= version.parse(
        "1.11.0"
    ), "datasets v1.11.0 or later required for SQuAD"

    def has_training_docs(self):
        return False

    def has_validation_docs(self):
        return True

    def has_test_docs(self):
        return False

    # def training_docs(self):
    #     return self.dataset["train"]

    def validation_docs(self):
        return self.dataset["validation"]

    def doc_to_text(self, doc):
        return (
            "Background: "
            + doc["context"]
            + "\n\n"
            + "Question: "
            + doc["question"]
            + "\n\n"
            + "Answer:"
        )

    def should_decontaminate(self):
        return True

    def doc_to_decontamination_query(self, doc):
        return doc["context"]

    def doc_to_target(self, doc):
        answer_list = doc["answers"]["text"]
        if len(answer_list) > 0:
            answer = answer_list[0]
        else:
            answer = "unanswerable"
        return " " + answer

    def construct_requests(self, doc, ctx, **kwargs):
        """Uses RequestFactory to construct Requests and returns an iterable of
        Requests which will be sent to the LM.

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param ctx: str
            The context string, generated by fewshot_context. This includes the natural
            language description, as well as the few shot examples, and the question
            part of the document for `doc`.
        """

        return [
            Instance(
                request_type="generate_until",
                doc=doc,
                arguments=(ctx, {"until": ["\n", "\n\n", "</s>"]}),
                idx=0,
                **kwargs,
            ),
            Instance(
                request_type="loglikelihood",
                doc=doc,
                arguments=(ctx, " " + "unanswerable"),
                idx=0,
                **kwargs,
            ),
        ]

    def process_results(self, doc, results):
        """Take a single document and the LM results and evaluates, returning a
        dict where keys are the names of submetrics and values are the values of
        the metric for that one document

        :param doc:
            The document as returned from training_docs, validation_docs, or test_docs.
        :param results:
            The results of the requests created in construct_requests.
        """

        continuation, (logprob_unanswerable, _) = results

        no_answer_probability = exp(logprob_unanswerable)

        predictions = {
            "id": doc["id"],
            "prediction_text": continuation,
            "no_answer_probability": no_answer_probability,
        }

        references = {
            "id": doc["id"],
            "answers": doc["answers"],
        }

        return {
            "exact": (
                predictions,
                references,
            ),  # Exact match (the normalized answer exactly match the gold answer)
            "f1": (
                predictions,
                references,
            ),  # The F-score of predicted tokens versus the gold answer
            "HasAns_exact": (
                predictions,
                references,
            ),  # Exact match (the normalized answer exactly match the gold answer)
            "HasAns_f1": (
                predictions,
                references,
            ),  # The F-score of predicted tokens versus the gold answer
            "NoAns_exact": (
                predictions,
                references,
            ),  # Exact match (the normalized answer exactly match the gold answer)
            "NoAns_f1": (
                predictions,
                references,
            ),  # The F-score of predicted tokens versus the gold answer
            "best_exact": (
                predictions,
                references,
            ),  # Best exact match (with varying threshold)
            "best_f1": (predictions, references),  # Best F1 (with varying threshold)
        }

    def aggregation(self):
        """
        :returns: {str: [float] -> float}
            A dictionary where keys are the names of submetrics and values are
            functions that aggregate a list of metrics
        """
        return {
            "exact": partial(
                _squad_agg, "exact"
            ),  # Exact match (the normalized answer exactly match the gold answer)
            "f1": partial(
                _squad_agg, "f1"
            ),  # The F-score of predicted tokens versus the gold answer
            "HasAns_exact": partial(
                _squad_agg, "HasAns_exact"
            ),  # Exact match (the normalized answer exactly match the gold answer)
            "HasAns_f1": partial(
                _squad_agg, "HasAns_f1"
            ),  # The F-score of predicted tokens versus the gold answer
            "NoAns_exact": partial(
                _squad_agg, "NoAns_exact"
            ),  # Exact match (the normalized answer exactly match the gold answer)
            "NoAns_f1": partial(
                _squad_agg, "NoAns_f1"
            ),  # The F-score of predicted tokens versus the gold answer
            "best_exact": partial(
                _squad_agg, "best_exact"
            ),  # Best exact match (with varying threshold)
            "best_f1": partial(
                _squad_agg, "best_f1"
            ),  # Best F1 (with varying threshold)
        }

    def higher_is_better(self):
        """
        :returns: {str: bool}
            A dictionary where keys are the names of submetrics and values are
            whether a higher value of the submetric is better
        """
        return {
            "exact": True,  # Exact match (the normalized answer exactly match the gold answer)
            "f1": True,  # The F-score of predicted tokens versus the gold answer
            "HasAns_exact": True,  # Exact match (the normalized answer exactly match the gold answer)
            "HasAns_f1": True,  # The F-score of predicted tokens versus the gold answer
            "NoAns_exact": True,  # Exact match (the normalized answer exactly match the gold answer)
            "NoAns_f1": True,  # The F-score of predicted tokens versus the gold answer
            "best_exact": True,  # Best exact match (with varying threshold)
            "best_f1": True,  # Best F1 (with varying threshold)
        }

class arXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/online1/ycsc_chenkh/hitici_02/data/eval_data/xquad"
    DATASET_NAME = "xquad.ar"
    
    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})
        
    def doc_to_text(self, doc):
        ar_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "خلفية",
                "Question": "سؤال",
                "Answer": "إجابة",
            },
        )
        return ar_doc_to_text_func(doc)


class zhXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/home/export/base/ycsc_chenkh/hitici_02/online1/data/eval_data/xquad"
    DATASET_NAME = "xquad.zh"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    def doc_to_text(self, doc):
        zh_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "背景",
                "Question": "问题",
                "Answer": "答案",
            },
        )
        return zh_doc_to_text_func(doc)


class deXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/home/export/base/ycsc_chenkh/hitici_02/online1/data/eval_data/xquad"
    DATASET_NAME = "xquad.de"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    def doc_to_text(self, doc):
        de_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "Hintergrund",
                "Question": "Frage",
                "Answer": "Antwort",
            },
        )
        return de_doc_to_text_func(doc)


class elXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/home/export/base/ycsc_chenkh/hitici_02/online1/data/eval_data/xquad"
    DATASET_NAME = "xquad.el"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    def doc_to_text(self, doc):
        el_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "Υπόβαθρο",
                "Question": "Ερώτηση",
                "Answer": "Απάντηση",
            },
        )
        return el_doc_to_text_func(doc)


class esXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/home/export/base/ycsc_chenkh/hitici_02/online1/data/eval_data/xquad"
    DATASET_NAME = "xquad.es"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    def doc_to_text(self, doc):
        es_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "Antecedentes",
                "Question": "Pregunta",
                "Answer": "Respuesta",
            },
        )
        return es_doc_to_text_func(doc)


class hiXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/home/export/base/ycsc_chenkh/hitici_02/online1/data/eval_data/xquad"
    DATASET_NAME = "xquad.hi"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    def doc_to_text(self, doc):
        hi_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "पृष्ठभूमि",
                "Question": "प्रश्न",
                "Answer": "उत्तर",
            },
        )
        return hi_doc_to_text_func(doc)


class roXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/home/export/base/ycsc_chenkh/hitici_02/online1/data/eval_data/xquad"
    DATASET_NAME = "xquad.ro"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    def doc_to_text(self, doc):
        ro_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "Fundal",
                "Question": "Întrebare",
                "Answer": "Răspuns",
            },
        )
        return ro_doc_to_text_func(doc)


class ruXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/home/export/base/ycsc_chenkh/hitici_02/online1/data/eval_data/xquad"
    DATASET_NAME = "xquad.ru"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    def doc_to_text(self, doc):
        ru_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "Фон",
                "Question": "Вопрос",
                "Answer": "Ответ",
            },
        )
        return ru_doc_to_text_func(doc)


class thXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/home/export/base/ycsc_chenkh/hitici_02/online1/data/eval_data/xquad"
    DATASET_NAME = "xquad.th"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    def doc_to_text(self, doc):
        th_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "พื้นหลัง",
                "Question": "คำถาม",
                "Answer": "คำตอบ",
            },
        )
        return th_doc_to_text_func(doc)


class trXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/home/export/base/ycsc_chenkh/hitici_02/online1/data/eval_data/xquad"
    DATASET_NAME = "xquad.tr"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    def doc_to_text(self, doc):
        tr_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "Arka plan",
                "Question": "Soru",
                "Answer": "Cevap",
            },
        )
        return tr_doc_to_text_func(doc)


class viXQuAD(XQuAD):
    VERSION = 1
    DATASET_PATH = "/home/export/base/ycsc_chenkh/hitici_02/online1/data/eval_data/xquad"
    DATASET_NAME = "xquad.vi"

    def __init__(self, config=None):
        super().__init__(config={"metadata": {"version": self.VERSION}})

    def doc_to_text(self, doc):
        vi_doc_to_text_func = partial(
            doc_to_text,
            connector={
                "Background": "Bối cảnh",
                "Question": "Câu hỏi",
                "Answer": "Câu trả lời",
            },
        )
        return vi_doc_to_text_func(doc)